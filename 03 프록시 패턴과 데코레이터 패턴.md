# 프록시 객체   

![image](https://user-images.githubusercontent.com/50267433/147443980-c37d2f90-8b4a-49e7-9464-0683e759a1c1.png)

클라이언트와 서버의 기본 개념을 정의하면      
클라이언트는 서버에 필요한 것을 요청하고,       
서버는 클라이언트의 요청을 처리하는 것이다.    
  
일반적으로 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받는다. **이것을 직접 호출이라 한다.**    

![image](https://user-images.githubusercontent.com/50267433/147444139-7e3cfc6b-de8c-4fe0-8896-988aae6bb3b3.png)
       
그런데 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 간접 호출하는 것          
즉, 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할 수 있는데 여기서 대리자를 프록시(Proxy)라 한다.         

![image](https://user-images.githubusercontent.com/50267433/147445002-7f21e0b4-75d8-416e-812a-694ed1efb7a3.png)
   
프록시는 또다른 프록시를 호출할 수 있다.          
중요한 점은 클라이언트는 대리자를 통해서 요청했기 때문에 그 이후 과정은 모른다는 점이다.     
단지, 요청을 통해서 내가 원하는 결과값을 도출해내기만 하면 된다.    
  
## 대체 기능  

객체에서 프록시가 되려면 클라이언트는 서버에게 요청한 것인지, 프록시에게 요청한 것인지 몰라야 한다.         
쉽게 이야기해서 **서버와 프록시는 같은 인터페이스를 사용해야 한다.**                
그리고 클라이언트가 사용하는 **서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.**          

![image](https://user-images.githubusercontent.com/50267433/147455352-ac76be82-d2a4-43c8-a3cd-6b62d54e9d69.png)
     
클라이언트는 서버 인터페이스에만 의존한다.           
그리고 서버와 프록시가 같은 인터페이스를 사용한다.       
즉, DI를 사용해서 대체 가능하다는 의미이기도 하다.  

## 주요 기능   
  
프록시를 통해서 할 수 있는 일은 크게 2가지로 구분할 수 있다. 

* 접근 제어
    * 권한에 따른 접근 차단 
    * 캐싱
    * 지연 로딩
* 부가 기능 추가
    * 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다. 
    * 예) 요청 값이나, 응답 값을 중간에 변형한다.
    * 예) 실행 시간을 측정해서 추가 로그를 남긴다.
    
프록시 객체가 중간에 있으면 크게 접근 제어와 부가 기능 추가를 수행할 수 있다.     

# 디자인 패턴 

디자인 패턴에서도 프록시 객체를 이용한 패턴이 있다.   
단, 동일한 구조를 가지지만 의도에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다.   
 
* 프록시 패턴 : 접근 제어가 목적   
* 데코레이터 패턴 : 새로운 기능 추가가 목적  
    
둘다 프록시를 사용하지만, 의도가 다른 점이 핵심이다.      

## 준비물 

**인터페이스**
```kt
fun interface Subject {
    fun operation(): String
}
```

**서버**
```kt
@Slf4j
class RealSubject : Subject {
    fun operation(): String {
        log.info("실제 객체 호출")
        sleep(1000)
        return "data"
    }

    private fun sleep(millis: Int) {
        try {
            Thread.sleep(millis.toLong())
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }
}
```
# 프록시 패턴  
```kt
@Slf4j
class CacheProxy(private val target: Subject) : Subject {
    private var cacheValue: String? = null
    
    fun operation(): String {
        log.info("프록시 호출")
        if (cacheValue == null) {
            cacheValue = target.operation()
        }
        return cacheValue
    }
}
```
프록시 패턴의 주요 기능은 접근 제어다.      
그리고 캐시도 접근 자체를 제어하는 기능 중 하나이다.     

![image](https://user-images.githubusercontent.com/50267433/147457355-3693b295-28b9-4a25-a7ee-cc08c0a8b191.png)
![image](https://user-images.githubusercontent.com/50267433/147457388-2bf81dba-6c47-4b83-b6ee-f8056f4c9518.png)
 
서버와 클라이언트 사이에, CacheProxy 가 들어오면서 RealSubject에서 계산한 값을 캐시하고 반환한다.    
이전 구조에서는 3초가 걸릴 작업을 단 1초만에 해결한 것이다.   
      
프록시 패턴의 핵심은 RealSubject 코드와 클라이언트 코드를 전혀 변경하지 않고, 프록시를 도입해서 접근 제어를 했다는 점이다.       
그리고 클라이언트 코드의 변경 없이 자유롭게 프록시를 넣고 뺄 수 있다.      
실제 클라이언트 입장에서는 프록시 객체가 주입되었는지, 실제 객체가 주입되었는지 알지 못한다.    




## 데코레이터 패턴 

 
