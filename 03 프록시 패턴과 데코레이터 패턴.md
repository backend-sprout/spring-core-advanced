# 프록시 객체   

![image](https://user-images.githubusercontent.com/50267433/147443980-c37d2f90-8b4a-49e7-9464-0683e759a1c1.png)

클라이언트와 서버의 기본 개념을 정의하면      
클라이언트는 서버에 필요한 것을 요청하고,       
서버는 클라이언트의 요청을 처리하는 것이다.    
  
일반적으로 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받는다. **이것을 직접 호출이라 한다.**    

![image](https://user-images.githubusercontent.com/50267433/147444139-7e3cfc6b-de8c-4fe0-8896-988aae6bb3b3.png)
       
그런데 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 간접 호출하는 것          
즉, 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할 수 있는데 여기서 대리자를 프록시(Proxy)라 한다.         

![image](https://user-images.githubusercontent.com/50267433/147445002-7f21e0b4-75d8-416e-812a-694ed1efb7a3.png)
   
프록시는 또다른 프록시를 호출할 수 있다.          
중요한 점은 클라이언트는 대리자를 통해서 요청했기 때문에 그 이후 과정은 모른다는 점이다.     
단지, 요청을 통해서 내가 원하는 결과값을 도출해내기만 하면 된다.    
  
## 대체 기능  

객체에서 프록시가 되려면 클라이언트는 서버에게 요청한 것인지, 프록시에게 요청한 것인지 몰라야 한다.         
쉽게 이야기해서 **서버와 프록시는 같은 인터페이스를 사용해야 한다.**                
그리고 클라이언트가 사용하는 **서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.**          

![image](https://user-images.githubusercontent.com/50267433/147455352-ac76be82-d2a4-43c8-a3cd-6b62d54e9d69.png)
     
클라이언트는 서버 인터페이스에만 의존한다.           
그리고 서버와 프록시가 같은 인터페이스를 사용한다.       
즉, DI를 사용해서 대체 가능하다는 의미이기도 하다.  

## 주요 기능   
  
프록시를 통해서 할 수 있는 일은 크게 2가지로 구분할 수 있다. 

* 접근 제어
    * 권한에 따른 접근 차단 
    * 캐싱
    * 지연 로딩
* 부가 기능 추가
    * 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다. 
    * 예) 요청 값이나, 응답 값을 중간에 변형한다.
    * 예) 실행 시간을 측정해서 추가 로그를 남긴다.
    
프록시 객체가 중간에 있으면 크게 접근 제어와 부가 기능 추가를 수행할 수 있다.     
