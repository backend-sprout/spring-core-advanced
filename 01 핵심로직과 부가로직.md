# 요구사항 

* 모든 PUBLIC 메서드의 호출과 응답 정보를 로그로 출력 
* 애플리케이션의 흐름을 변경하면 안됨
    * 로그를 남긴다고 해서 비즈니스 로직의 동작에 영향을 주면 안됨 메서드 호출에 걸린 시간
* 정상 흐름과 예외 흐름 구분
    * 예외 발생시 예외 정보가 남아야 함
* 메서드 호출의 깊이 표현 
* HTTP 요청을 구분
    * HTTP 요청 단위로 특정 ID를 남겨서 어떤 HTTP 요청에서 시작된 것인지 명확하게 구분이 가능해야 함
    * 트랜잭션 ID (DB 트랜잭션X), 여기서는 하나의 HTTP 요청이 시작해서 끝날 때 까지를 하나의 트랜잭션이라 함

## 준비물 

**LogTrace**
```kt
interface LogTrace {

    fun begin(message: String): TraceStatus

    fun end(traceStatus: TraceStatus)

    fun exception(traceStatus: TraceStatus, e: Exception)
}
```

**FieldLogTrace**
```kt
class FieldLogTrace : LogTrace {
    private var traceIdHolder: TraceId? = null
    private val log: Logger = LoggerFactory.getLogger(javaClass)

    override fun begin(message: String): TraceStatus {
        syncTraceId()
        val traceId = traceIdHolder!!
        val startTimeMs = System.currentTimeMillis()
        log.info("[{}] {}{}", traceId.id, addSpace(START_PREFIX, traceId.level), message)
        return TraceStatus(traceId, startTimeMs, message)
    }

    private fun syncTraceId() {
        if (traceIdHolder == null) {
            traceIdHolder = TraceId()
        } else {
            traceIdHolder = traceIdHolder!!.createNextId()
        }
    }

    override fun end(traceStatus: TraceStatus): Unit = complete(traceStatus, null)

    override fun exception(traceStatus: TraceStatus, e: Exception): Unit = complete(traceStatus, e)

    private fun complete(status: TraceStatus, e: java.lang.Exception?) {
        val stopTimeMs = System.currentTimeMillis()
        val resultTimeMs = stopTimeMs - status.startTimeMs
        val traceId = status.traceId
        if (e == null) {
            log.info(
                "[{}] {}{} time={}ms", traceId.id,
                addSpace(COMPLETE_PREFIX, traceId.level), status.message,
                resultTimeMs
            )
        } else {
            log.info(
                "[{}] {}{} time={}ms ex={}", traceId.id,
                addSpace(EX_PREFIX, traceId.level), status.message, resultTimeMs,
                e.toString()
            )
        }
        releaseTraceId()
    }

    private fun releaseTraceId() {
        if (traceIdHolder!!.isFirstLevel()) {
            traceIdHolder = null
        } else {
            traceIdHolder = traceIdHolder!!.createPreviousId()
        }
    }

    companion object {

        private const val START_PREFIX = "-->"
        private const val COMPLETE_PREFIX = "<--"
        private const val EX_PREFIX = "<X-"

        private fun addSpace(prefix: String, level: Int): String {
            val sb = StringBuilder()
            for (i in (0 until level)) {
                sb.append(if (i == level - 1) "|$prefix" else "|   ")
            }
            return sb.toString()
        }
    }
}
```

# 핵심로직과 부가로직 
비즈니스로직에서 `처리 시간 측정`, `로깅`, `트랜잭션처리`등과 같은 부가기능을 적용하기는 어렵다.      
이 같은 기능들은 꼭 필요하지만 막상 추가하려다보면, 비즈니스 로직을 더럽히는 문제가 발생한다.          
더불어, 부가기능이 필요한 모든 곳에 코드에 대한 중복이 발생하고 이들을 일일히 관리하기 어려운 문제가 발생한다.        

**더럽혀진 코드**
```kt
@RestController
class OrderControllerV3(
    private val orderService: OrderServiceV3,
    private val logTrace: LogTrace
) {

    @GetMapping("/v3/request")
    fun request(itemId: String): String {
        val status = logTrace.begin("OrderController.request()")
        try {
            orderService.orderItem(itemId)
            logTrace.end(status)
            return "ok"
        } catch (e: Exception) {
            logTrace.exception(status, e)
            throw e
        }
    }
}
```   
     
이 같은 문제에 대해서 스프링을 많이 사용해본 사람들은 알겠지만, AOP 기능이 있다.           
하지만, 더 근본적으로 AOP는 어떤 방식으로 구현되어있고 어떻게 흘러가는지 아는 것이 중요하다.           
